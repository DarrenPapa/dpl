# Parser and Preprocessor
# The heart, the interpreter of DPL

import os
import time
import itertools
import dill
from copy import deepcopy as copy
from . import arguments as argproc
from . import varproc
from . import info
from . import state
from . import error
from . import utils

# Global preprocessing rules
rules = {
    "strict_include":0,
    "automatic_def":1,
    "warnings":1
}

# Set of included files.
includes = set()

def rule_enabled(rule):
    "Check if a rule is enabled"
    if rule not in rules:
        error.pre_warn(f"Invalid rule {rule!r}")
        return False
    return bool(rules.get(rule))

def enable_rule(rule):
    "Enable a rule"
    rules[rule] = 1

def disable_rule(rule):
    "Disable a rule"
    if rule not in rules:
        error.pre_warn(f"Invalid rule {rule!r}")
        return
    rules[rule] = 0
    
def get_block(code, current_p):
    "Get a code block"
    pos, file, _, _ = code[current_p]
    p = current_p + 1
    k = 1
    res = []
    while p < len(code):
        _, _, ins, _ = code[p]
        if ins in info.INC:
            k += 1
        elif ins in info.DEC:
            k -= 1
        if k == 0:
            break
        else:
            res.append(code[p])
        p += 1
    else:
        print(f"Error in line {pos} file {file!r}\nCause: Block wasnt closed!")
        return None
    return p, res

def process(code, name="__main__"):
    "Preprocess a file"
    res = []
    for lpos, line in filter(lambda x: (
        True if x[1] and not x[1].startswith("#") else False
    ),enumerate(map(str.strip, code.split("\n")), 1)):
        if line.startswith("&"):
            ins, *args = line[1:].lstrip().split()
            argc = len(args)
            if ins == "include" and argc == 1:
                file = args[0]
                x = tuple( # Generate likely paths
                    filter(
                        lambda x: os.path.isfile(x),
                        map(
                            lambda x: os.path.join(x, file),
                            varproc.meta["internal"]["search_paths"]
                        )
                    )
                )
                if len(x) > 1 and rule_enabled("strict_include"):
                    if rule_enabled("warnings"):
                        error.pre_error(lpos, name, f"{name!r}-{lpos}: Multiple candidates for {file!r} while including!")
                    break
                if len(x) > 1:
                    if rule_enabled("warnings"):
                        error.pre_warn(f"{name!r}-{lpos}: Multiple candidates for {file!r} while including!\nChose the first one!")
                file = x[0]
                if file in includes:
                    if rule_enabled("warnings"):
                        error.pre_warn(f"{name!r}-{lpos}: Already included {file!r}!")
                    if rule_enabled("strict_include"):
                        break
                if rule_enabled("automatic_def"):
                    includes.add(name)
                with open(file, "r") as f:
                    res.extend(process(f.read(), name=file))
            elif ins == "enable" and argc == 1:
                enable_rule(args[0])
            elif ins == "disable" and argc == 1:
                disable_rule(args[0])
            elif ins == "define" and argc == 0:
                includes.add(name)
            else:
                error.pre_error(lpos, name, f"{name!r}-{lpos}:Invalid directive {ins!r}")
                break
        else:
            ins, *args = line.split()
            args = argproc.exprs_preruntime(args)
            if res and ins in {
                "set"
            }:
                if name == res[-1][1] and ins == res[-1][2] and args == res[-1][3]:
                    continue
            elif res and ins in {
                "pass"
            }:
                if name == res[-1][1] and ins == res[-1][2]:
                    continue
            res.append((lpos, name, ins, args))
    else:
        return res
    return []

def run(code, frame=None):
    "Run code generated by 'process'"
    p = 0
    end_time = start_time = 0
    frame = varproc.new_frame() if frame is None else frame
    while p < len(code):
        pos, file, ins, args = code[p]
        if ins not in { # Lazy evaluation
            "while",
            "set_lazy"
        }:
            try:
                args = argproc.exprs_runtime(frame, args)
            except Exception as e:
                error.error(pos, file, f"Something went wrong when arguments were processed:\n{e}\n> {args!r}")
                break
        if varproc.is_debug_enabled("show_instructions"):
            error.info(f"Executing: {code[p]}")
        argc = len(args)
        if ins == "fn" and argc >= 1:
            name, *params = args
            temp = get_block(code, p)
            if temp is None:
                break
            else:
                p, body = temp
            varproc.rset(frame[-1], name, {
                "name":name,
                "body":body,
                "args":params,
                "self":state.bstate("nil"),
                "defs":{}
            })
        elif ins == "method" and argc >= 2:
            self, name, *params = args
            temp = get_block(code, p)
            if temp is None:
                break
            else:
                p, body = temp
            varproc.rset(self, name, {
                "name":name,
                "body":body,
                "args":params,
                "self":self,
                "defs":{}
            })
        elif ins == "object" and argc == 1:
            varproc.rset(frame[-1], args[0], {
                "_internal":{
                    "name":args[0],
                    "type":"type:"+args[0]
                }
            })
        elif ins == "new" and argc == 2:
            obj = varproc.rget(frame[-1], args[0])
            if obj == state.bstate("nil"):
                error.error(pos, file, f"Unknown object {args[0]!r}")
                break
            varproc.rset(obj, "_internal.name", args[1])
            varproc.rset(frame[-1], args[1], obj)
        elif ins == "for" and argc == 3 and args[1] == "in":
            name, _, iter = args
            temp = get_block(code, p)
            if temp is None:
                break
            else:
                p, body = temp
            for i in iter:
                varproc.rset(frame[-1], name, i)
                err = run(body, frame)
                if err == -1:
                    break
                elif err == -2:
                    continue
                elif err:
                    return err
        elif ins == "loop" and argc == 0:
            temp = get_block(code, p)
            if temp is None:
                break
            else:
                p, body = temp
            while True:
                err = run(body, frame)
                if err == -1:
                    break
                elif err == -2:
                    continue
                elif err:
                    return err
        elif ins == "while" and argc != 0:
            temp = get_block(code, p)
            if temp is None:
                break
            else:
                p, body = temp
            while True:
                try:
                    res, = argproc.exprs_runtime(frame, args)
                    if not res:
                        break
                except Exception as e:
                    error.error(pos, file, f"Something went wrong when arguments were processed:\n{e}\n> {args!r}")
                    return 1
                err = run(body, frame)
                if err == -1:
                    break
                elif err == -2:
                    continue
                elif err:
                    return err
        elif ins == "loop" and argc == 1:
            temp = get_block(code, p)
            if temp is None:
                break
            else:
                p, body = temp
            for _ in range(args[0]):
                err = run(body, frame)
                if err == -1:
                    break
                elif err == -2:
                    continue
                elif err:
                    return err
        elif ins == "stop" and argc == 0:
            return -1
        elif ins == "skip" and argc == 0:
            return -2
        elif ins == "set" and argc == 2:
            varproc.rset(frame[-1], args[0], args[1])
        elif ins == "set_lazy" and argc >= 2:
            name, *expr = args
            name = argproc.expr_runtime(frame, name)
            varproc.rset(frame[-1], name, expr)
        elif ins == "evaluate" and argc == 2:
            varproc.rset(frame[-1], name, argproc.exprs_runtime(frame, args[1]))
        elif ins == "println":
            for item in args:
                if isinstance(item, dict) and "_internal" in item and "_im_repr" in item:
                    varproc.nscope(frame)
                    varproc.nscope(frame)
                    varproc.rset(frame[-1], "self", item)
                    varproc.rset(frame[-1], "_returns", ("repr",))
                    err = run(item["_im_repr"]["body"], frame)
                    if err:
                        return err
                    varproc.pscope(frame)
                    repr = frame[-1].get("repr", state.bstate("nil"))
                    varproc.pscope(frame)
                    print(repr, end=' ' if item != args[-1] else '')
                else:
                    print(item, end=' ' if item != args[-1] else '')
            print()
        elif ins == "print":
            for item in args:
                if isinstance(item, dict) and "_internal" in item and "_im_repr" in item:
                    varproc.nscope(frame)
                    varproc.nscope(frame)
                    varproc.rset(frame[-1], "self", item)
                    varproc.rset(frame[-1], "_returns", ("repr",))
                    err = run(item["_im_repr"]["body"], frame)
                    if err:
                        return err
                    varproc.pscope(frame)
                    repr = frame[-1].get("repr", state.bstate("nil"))
                    varproc.pscope(frame)
                    print(repr, end=' ' if item != args[-1] else '')
                else:
                    print(item, end=' ' if item != args[-1] else '')
        elif ins == "input" and argc == 1:
            varproc.rset(frame[-1], args[0], input())
        elif ins == "catch" and argc >= 2: # Catch the return arguments of a function
            rets, name, *args = args
            if (temp:=varproc.rget(frame[-1], name)) == state.bstate("nil") and not isinstance(temp, dict):
                error.error(p, file, f"Invalid function {name!r}!")
                break
            varproc.nscope(frame)
            for name, value in zip(temp["args"], args):
                varproc.rset(frame[-1], name, value)
            varproc.rset(frame[-1], "_returns", rets)
            if temp["self"] != state.bstate("nil"):
                varproc.rset(frame[-1], "self", temp["self"])
            err = run(temp["body"], frame)
            if err:
                return err
            varproc.pscope(frame)
        elif ins == "return" and (temp:=varproc.rget(frame[-1], "_returns")) != state.bstate("nil"): # Return to the latched names
            for name, value in zip(temp, args):
                varproc.rset(frame[-1], f"_nonlocal.{name}", value)
        elif (temp:=varproc.rget(frame[-1], ins)) != state.bstate("nil") and isinstance(temp, dict) and argc == 1: # Call a function
            varproc.nscope(frame)
            if temp["defs"]:
                for name, value in itertools.zip_longest(temp["args"], args[0]):
                    if value is None:
                        varproc.rset(frame[-1], name, temp["defs"].get(name, state.bstate("nil")))
                    else:
                        varproc.rset(frame[-1], name, value)
            else:
                if len(args[0]) != len(temp["args"]):
                    error.error(pos, file, f"Function {ins!r} has a parameter mismatch!\nGot {'more' if len(args[0]) > len(temp['args']) else 'less'} than expected.")
                    break
                for name, value in itertools.zip_longest(temp["args"], args[0]):
                    varproc.rset(frame[-1], name, value)
            if temp["self"] != state.bstate("nil"):
                varproc.rset(frame[-1], "self", temp["self"])
            err = run(temp["body"], frame)
            if err:
                return err
            varproc.pscope(frame)
        elif (temp:=varproc.rget(frame[-1], ins)) != state.bstate("nil") and isinstance(temp, dict) and argc == 1: # Call a function
            varproc.nscope(frame)
            if temp["defs"]:
                for name in temp["args"]:
                    varproc.rset(frame[-1], name, temp["defs"].get(name, state.bstate("nil")))
            else:
                if 0 != len(temp["args"]):
                    error.error(pos, file, f"Function {ins!r} has a parameter mismatch!\nGot more than expected.")
                    break
            if temp["self"] != state.bstate("nil"):
                varproc.rset(frame[-1], "self", temp["self"])
            err = run(temp["body"], frame)
            if err:
                return err
            varproc.pscope(frame)
        elif ins == "START_TIME" and argc == 0:
            start_time = time.time()
        elif ins == "STOP_TIME" and argc == 0:
            end_time = time.time() - start_time
        elif ins == "LOG_TIME" and argc == 0:
            ct, unit = utils.convert_sec(end_time)
            error.info(f"Elapsed time: {ct:.8f}{unit}")
        elif ins == "if" and argc == 1:
            temp = get_block(code, p)
            if temp is None:
                break
            else:
                p, body = temp
            if args[0]:
                err = run(body, frame=frame)
                if err:
                    return err
        elif ins == "pass":
            ...
        else:
            error.error(pos, file, f"Invalid instruction {ins}")
            break
        p += 1
    else:
        return 0
    error.error(pos, file, "Error was raised!")
    return 1